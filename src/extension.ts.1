import * as vscode from 'vscode';
import fetch from 'node-fetch';

// Configuration interface
interface MicropubConfig {
    token: string;
    endpoint: string;
}

export function activate(context: vscode.ExtensionContext) {
    // Register the publish command
    let disposable = vscode.commands.registerCommand('micropub.publish', async () => {
        try {
            const config = getConfiguration();
            if (!config) {
                return;
            }

            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showErrorMessage('No active editor');
                return;
            }

            const content = editor.document.getText();
            const parsedContent = parseMarkdownContent(content);
            
            await publishPost(parsedContent, config);
            vscode.window.showInformationMessage('Successfully published to micro.blog');
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
            vscode.window.showErrorMessage(`Failed to publish: ${errorMessage}`);
        }
    });

    context.subscriptions.push(disposable);
}

function getConfiguration(): MicropubConfig | undefined {
    const config = vscode.workspace.getConfiguration('micropub');
    const token = config.get<string>('token');
    const endpoint = config.get<string>('endpoint');

    if (!token || !endpoint) {
        vscode.window.showErrorMessage('Micropub configuration missing. Please set token and endpoint.');
        return undefined;
    }

    return { token, endpoint };
}

interface ParsedContent {
    title?: string;
    content: string;
    tags?: string[];
}

function parseMarkdownContent(content: string): ParsedContent {
    const lines = content.split('\n');
    let inFrontMatter = false;
    let frontMatter = '';
    let mainContent = '';
    let title: string | undefined;
    let tags: string[] = [];

    for (const line of lines) {
        if (line.trim() === '---') {
            inFrontMatter = !inFrontMatter;
            continue;
        }

        if (inFrontMatter) {
            frontMatter += line + '\n';
        } else {
            mainContent += line + '\n';
        }
    }

    // Parse front matter
    if (frontMatter) {
        const titleMatch = frontMatter.match(/title:\s*(.+)/);
        if (titleMatch) {
            title = titleMatch[1].trim();
        }

        const tagsMatch = frontMatter.match(/tags:\s*\[(.*)\]/);
        if (tagsMatch) {
            tags = tagsMatch[1].split(',').map(tag => tag.trim());
        }
    }

    return {
        title,
        content: mainContent.trim(),
        tags: tags.length > 0 ? tags : undefined
    };
}

async function publishPost(parsed: ParsedContent, config: MicropubConfig): Promise<void> {
    const micropubRequest = {
        type: ['h-entry'],
        properties: {
            content: [parsed.content],
            ...(parsed.title && { name: [parsed.title] }),
            ...(parsed.tags && { category: parsed.tags })
        }
    };

    const response = await fetch(config.endpoint, {
        method: 'POST',
        headers: {
            'Authorization': `Bearer ${config.token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(micropubRequest)
    });

    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
}

